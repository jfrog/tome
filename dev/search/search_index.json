{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"tome","text":"<p>A set of tools to organize, share\u202f&amp;\u202frun scripts</p>"},{"location":"#what-can-tome-do","title":"What can tome do?","text":"<ul> <li>\ud83d\udcc2 Organise \u2013 keep your scripts tidy and always   accessible with a clear folder structure.</li> <li>\ud83e\udd1d Share \u2013 distribute your script collections via Git,   archives, or local folders.</li> <li>\ud83e\uddea Test \u2013 test scripts in one line to make sure they   work as expected.</li> <li>\ud83d\udd12 Secure \u2013 manage secrets with tome vault.</li> </ul>"},{"location":"#install","title":"Install","text":"<p>Create and activate a virtual environment. For detailed instructions, refer to the install guide. Then, install tome using <code>pip</code>:</p> pip install tomescripts \ud83c\udf89  Tome installed. tome --version 0.2.0"},{"location":"#hello-world-in-30-seconds","title":"Hello\u00a0world in 30\u202fseconds","text":"<p>Use <code>tome new</code> to create a template for a command. Then install it in editable mode. Now your changes are reloaded instantly. Afterwards, list all available commands and run it.</p> <pre><code># create a new command\n$ tome new greetings:hello\n\n# install in editable mode\n$ tome install . -e\n\n# list installed commands\n$ tome list\n\n\ud83d\udcd6 /some/path/my-tome\n\n  \ud83c\udf32 greetings commands\n     greetings:hello (e)  Description of the command.\n\n# run it!\n$ tome greetings:hello Hello!\n ________\n&lt; Hello! &gt;\n --------\n        \\\\   @..@\n         \\\\ (----)\n           ( &gt;__&lt; )\n           ^^ ~~ ^^\n</code></pre> <p>Install the examples from a third party, in this case the tome repository:</p> <pre><code># install tome examples from the github repository\n$ tome install https://github.com/jfrog/tome.git --folder=examples\n\n# list installed commands\n$ tome list\n\n\ud83d\udcd6 https://github.com/jfrog/tome.git\n\n  \ud83c\udf10 network commands\n     network:ping-bat            Script to ping an IP address or URL...\n     network:ping-sh             Script to ping an IP address or URL...\n     network:traceroute-bat      Script to perform a traceroute to an IP address or URL...\n     network:traceroute-sh       Script to perform a traceroute to an IP address or URL...\n\n  \ud83d\udda5\ufe0f  system commands\n     system:monitor              Monitor system usage including CPU, memory, and disk.\n\n  \ud83d\udc2e utils commands\n     utils:todo                  A simple command-line To-Do list manager.\n\n# ask for help\n$ tome system:monitor --help\nusage: tome monitor [-h] [-v] [-q] [--cpu] [--memory] [--disk]\n\nMonitor system usage including CPU, memory, and disk.\n\noptions:\n  -h, --help     show this help message and exit\n  -v, --verbose  Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet    Reduce the output to a minimum, showing only critical errors\n  --cpu          Monitor CPU usage in real-time\n  --memory       Monitor memory usage in real-time\n  --disk         Display disk usage\n\n# run the command\n$ tome system:monitor --cpu --memory --disk\nDisk Usage: 1.5% used\nTotal: 926.35 GB\nUsed: 10.47 GB\nFree: 695.70 GB\nCPU Usage: 19.1%\nMemory Usage: 60.5%\nTotal: 36.00 GB\nUsed: 14.75 GB\nAvailable: 14.24 GB\nFree: 2.00 GB\n</code></pre>"},{"location":"#whats-next","title":"What's Next?","text":"Goal Documentation \ud83d\ude80 Get started in 5 minutes Quickstart \ud83d\udcda Explore all CLI commands CLI Reference \u2728 Contribute or get support Contribution Guide in GitHub"},{"location":"license/","title":"License","text":"<p>tome is licensed under the Apache License, Version 2.0. You can view the full license text directly on GitHub</p>"},{"location":"guides/","title":"Guides","text":"<p>This section provides practical, step-by-step guides to help you perform common tasks and explore various features of tome. Choose a guide below to learn more:</p> <ul> <li>Tome Scripts In-Depth: Learn to create Python commands,   from simple functions to those with subcommands, argument parsing, and custom   output formatters.</li> <li>Sharing your scripts: Discover how to package and distribute   your Tomes using Git, local folders, or archives.</li> <li>Testing your scripts: A guide on writing and running tests   for your tome commands using <code>pytest</code>.</li> <li>Migrate a shell script: Integrate your existing shell or   Python scripts into the tome framework.</li> <li>Relevant Features:<ul> <li>Vault: Discover how to securely manage secrets   and use them in your commands.</li> <li>Store: Learn how to use tome's local storage   API for persistent data.</li> </ul> </li> </ul>"},{"location":"guides/in_depth/","title":"Tome Scripts In-Depth","text":"<p>Now that you've seen the basics of creating and running a simple command in the Quickstart, this guide dives deeper into building more structured and powerful tome commands with Python.</p> <p>We'll explore how to:</p> <ul> <li>Organize related actions using subcommands.</li> <li>Create flexible output presentations with formatters.</li> <li>Persist and retrieve data using tome's Store API.</li> </ul>"},{"location":"guides/in_depth/#1-the-utilstodo-command-and-its-subcommands","title":"1. The <code>utils:todo</code> command and its subcommands","text":"<p>For this guide, we'll build a simple command-line To-Do list manager called <code>utils:todo</code> the will have several subcommands to allow us to:</p> <ul> <li><code>tome utils:todo add</code>: Add new tasks.</li> <li><code>tome utils:todo list</code>: List existing tasks.</li> <li><code>tome utils:todo mark</code>: Mark tasks as done.</li> <li><code>tome utils:todo remove</code>: Remove tasks.</li> </ul>"},{"location":"guides/in_depth/#2-setting-up-the-script","title":"2. Setting Up the Script","text":"<p>First, if you haven't already, create a directory for your project (e.g., <code>my-scripts</code>) and navigate into it. Then, use <code>tome new</code> to create the initial script for the <code>todo</code> command within a <code>utils</code> namespace. The main function can be named <code>todo</code>.</p> <pre><code>$ mkdir my-scripts\n$ cd my-scripts\n$ tome new utils:todo\nGenerated script: utils/todo.py\n</code></pre> <p>Also install it as editable at this point so we can check our changes as we introduce them.</p> <pre><code>$ tome install . -e\nConfigured editable installation for ...\nInstalled source: ...\n</code></pre>"},{"location":"guides/in_depth/#3-implementing-subcommands","title":"3. Implementing Subcommands","text":"<p>Let's edit <code>utils/todo.py</code>. Let's start by defining the main <code>todo</code> command and its first subcommand, <code>add</code>. For data persistence, we'll use a simple JSON file stored via tome's Store API.</p> <pre><code>from tome.command import tome_command\nfrom tome.api.output import TomeOutput\n\n@tome_command()\ndef todo(tome_api, parser, *args):\n    \"\"\"\n    A simple command-line To-Do list manager.\n    \"\"\"\n    pass\n\n@tome_command(parent=todo)\ndef add(tome_api, parser, *args):\n    \"\"\"Adds a new task to the list.\"\"\"\n    parser.add_argument('description', help=\"The description of the task.\")\n    parsed_args = parser.parse_args(*args)\n\n    TomeOutput(stdout=True).info(f\"Task '{parsed_args.description}' added (not saved yet).\")\n</code></pre> <p>Explanation of Subcommand Structure:</p> <ul> <li>The main <code>todo</code> function is decorated with <code>@tome_command()</code> but just declares   a <code>pass</code> because it takes no arguments it's just the entry point for the   subcommands.</li> <li>The <code>add</code> subcommand is decorated with   <code>@tome_command(parent=todo)</code>, making it subcommands of <code>todo</code>.</li> <li>The <code>add</code> subcommand defines its own arguments using the <code>parser</code> object it   receives.</li> </ul> <p>At this point this does not do much:</p> <pre><code>$ tome utils:todo add \"Buy groceries\"\nTask 'Buy groceries' added (not saved).\n</code></pre> <p>Let's make some improvements:</p>"},{"location":"guides/in_depth/#4-using-the-store-api-tome_apistorefolder-for-persistent-data","title":"4. Using the Store API (<code>tome_api.store.folder</code>) for Persistent Data","text":"<p>Our <code>add</code> subcommand, as defined in the previous step, prints a message but doesn't actually save the task anywhere. To make our To-Do list useful, we need to store the tasks persistently so they can be retrieved later.</p> <p>This is where tome's Store API comes in handy. The <code>tome_api</code> object passed to your command functions has an attribute <code>store.folder</code>, which provides a consistent, managed directory path within your tome home (usually <code>~/.tome/storage/</code>). Your scripts can use this location to save and read data files.</p> <p>Let's modify our <code>utils/todo.py</code> script. We will update the <code>add</code> subcommand to save the new task into a JSON file named <code>mytasks.json</code>, located within a <code>utils_todo</code> subdirectory inside the path provided by <code>tome_api.store.folder</code>.</p> <pre><code>from tome.command import tome_command\nfrom tome.api.output import TomeOutput\nimport json\nimport os\n\nTASKS_FILE_NAME = \"mytasks.json\"\n\n@tome_command()\ndef todo(tome_api, parser, *args):\n    \"\"\"\n    A simple command-line To-Do list manager.\n    \"\"\"\n    pass\n\n@tome_command(parent=todo)\ndef add(tome_api, parser, *args):\n    \"\"\"Adds a new task to the list.\"\"\"\n    parser.add_argument('description', help=\"The description of the task.\")\n    parsed_args = parser.parse_args(*args)\n\n    task_description = parsed_args.description\n\n    utility_storage_path = os.path.join(tome_api.store.folder, \"utils_todo\")\n    os.makedirs(utility_storage_path, exist_ok=True)\n    tasks_file_path = os.path.join(utility_storage_path, TASKS_FILE_NAME)\n\n    tasks = []\n    if os.path.exists(tasks_file_path):\n        try:\n            with open(tasks_file_path, 'r') as f:\n                tasks = json.load(f)\n        except (json.JSONDecodeError, IOError):\n            tasks = []\n\n    new_task = {\"description\": task_description}\n    tasks.append(new_task)\n\n    try:\n        with open(tasks_file_path, 'w') as f:\n            json.dump(tasks, f, indent=2)\n\n        TomeOutput(stdout=True).info(f\"Task '{task_description}' saved in '{tasks_file_path}'.\")\n    except IOError:\n        TomeOutput().error(f\"Could not save task to '{tasks_file_path}'.\")\n</code></pre> <p>Explanation of the changes:</p> <ul> <li>A constant <code>TASKS_FILE_NAME</code> is defined.</li> <li>Inside <code>add</code>, <code>utility_storage_path</code> is created using <code>tome_api.store.folder</code>   combined with a subdirectory <code>utils_todo</code> for better organization within the   global store. <code>os.makedirs(utility_storage_path, exist_ok=True)</code> ensures this   path exists.</li> <li><code>tasks_file_path</code> is the full path to our <code>mytasks.json</code>.</li> <li>We attempt to load existing tasks from this file. If the file doesn't exist or   is invalid, we start with an empty list (<code>tasks = []</code>).</li> <li>The <code>new_task</code> dictionary currently only stores the <code>description</code>.</li> <li>The updated <code>tasks</code> list is then saved back to <code>mytasks.json</code> using   <code>json.dump()</code>.</li> <li>A confirmation message, including the path to the saved file, is printed.</li> </ul> <p>Now, when you run the <code>add</code> subcommand, the task is saved:</p> <pre><code>$ tome utils:todo add \"Buy groceries\"\nTask 'Buy groceries' saved in '~/.tome/storage/utils_todo/mytasks.json'.\n\n$ cat '~/.tome/storage/utils_todo/mytasks.json'\n</code></pre> <p>You can inspect the <code>mytasks.json</code> file (the exact path will be shown in your output) to see the saved tasks:</p> <pre><code>[\n  {\n    \"description\": \"Buy groceries\"\n  }\n]\n</code></pre> <p>This demonstrates how the Store API provides a clean way to handle persistent data for your commands without needing to manage complex pathing or worry about where to place user-specific data.</p>"},{"location":"guides/in_depth/#5-standarazing-output-using-formatters","title":"5. Standarazing Output using Formatters","text":"<p>Our subcommands currently is printing a success message to <code>stdout</code> but tome provides a way of presenting information in a more structured? way using <code>formatters</code>.  Let's define formatters for our <code>list</code> subcommand. We'll add a <code>text</code> formatter and a <code>JSON</code> formatter.</p> <p>Modify <code>utils/todo.py</code> to include these formatter functions and update the <code>@tome_command</code> decorator for <code>list</code>:</p> <pre><code>from tome.command import tome_command\nfrom tome.api.output import TomeOutput\nfrom tome.errors import TomeException\nimport json\nimport os\n\nTASKS_FILE_NAME = \"mytasks.json\"\n\ndef todo_text_formatter(data_dict):\n    if data_dict.get(\"status\") == \"success\" and \"message\" in data_dict:\n        TomeOutput(stdout=True).info(data_dict[\"message\"])\n    elif data_dict.get(\"status\") == \"error\" and \"error\" in data_dict:\n        raise TomeException(data_dict[\"error\"])\n\ndef todo_json_formatter(data_dict):\n    TomeOutput(stdout=True).print_json(json.dumps(data_dict, indent=2))\n\n    if data_dict.get(\"status\") == \"error\" and \"error\" in data_dict:\n        raise TomeException(data_dict[\"error\"])\n\n\n@tome_command()\ndef todo(tome_api, parser, *args):\n    \"\"\"\n    A simple command-line To-Do list manager.\n    \"\"\"\n    pass\n\n@tome_command(parent=todo, formatters={\"text\": todo_text_formatter, \"json\": todo_json_formatter})\ndef add(tome_api, parser, *args):\n    \"\"\"Adds a new task to the list.\"\"\"\n    parser.add_argument('description', help=\"The description of the task.\")\n    parsed_args = parser.parse_args(*args)\n\n    task_description = parsed_args.description\n\n    utility_storage_path = os.path.join(tome_api.store.folder, \"utils_todo\")\n    os.makedirs(utility_storage_path, exist_ok=True)\n    tasks_file_path = os.path.join(utility_storage_path, TASKS_FILE_NAME)\n\n    tasks = []\n    if os.path.exists(tasks_file_path):\n        try:\n            with open(tasks_file_path, 'r') as f:\n                tasks = json.load(f)\n        except (json.JSONDecodeError, IOError):\n            tasks = []\n\n    new_task = {\"description\": task_description}\n    tasks.append(new_task)\n\n    try:\n        with open(tasks_file_path, 'w') as f:\n            json.dump(tasks, f, indent=2)\n\n        return {\n            \"action\": \"add\",\n            \"status\": \"success\",\n            \"message\": f\"Task '{task_description}' added.\",\n            \"description\": task_description\n        }\n    except IOError as e:\n        return {\n            \"action\": \"add\",\n            \"status\": \"error\",\n            \"error\": f\"Could not save task to '{tasks_file_path}': {str(e)}\",\n            \"description\": task_description\n        }\n</code></pre> <p>Understanding the Changes:</p> <ul> <li>The <code>@tome_command()</code> decorator for <code>add</code> was updated with a <code>formatters</code> argument.</li> <li>The <code>add</code> function now <code>return</code>s a dictionary, whether for success or a   validation error.</li> <li>We defined <code>todo_text_formatter</code> and <code>todo_json_formatter</code> to handle the dictionary   returned by <code>add</code> you can select which one you want to use when running   <code>utils:todo add</code> with the <code>--format</code> argument. The <code>text</code> one is used by   default if the <code>--format</code> argument is not passed.</li> <li>The <code>todo_text_formatter</code> raises a <code>TomeException</code> if it finds an error in the   data, ensuring tome reports it.</li> <li>The <code>todo_json_formatter</code> prints the JSON (which will include the error structure   if present) and then raises <code>TomeException</code> if an error key exists, so   automated tools get structured error data but the script still exits with an   error code.</li> </ul> <p>Now, tome automatically adds a <code>--format</code> option to your command.</p> <p>Try it out:</p> <p>Default text output:</p> <pre><code>$ tome utils:todo add \"Buy groceries\"\nTask 'Buy groceries' added.\n\n\n$ tome utils:todo add \"Take the dog out\" --format=json\n{\n  \"action\": \"add\",\n  \"status\": \"success\",\n  \"message\": \"Task 'Take the dog out' added.\",\n  \"description\": \"Take the dog out\"\n}\n</code></pre> <p>Using formatters like this keeps your command's core logic separate from its presentation, making your code cleaner. Plus, you can easily offer different output styles (e.g., text for users, JSON for tools) from a single command, making it more maintainable. You can learn more about how to define and use them in the Output Formatters Reference.</p>"},{"location":"guides/in_depth/#6-finishing-the-command","title":"6. Finishing the command","text":"<p>You can find the full implementation in the examples folder in the GitHub repository. Please, copy and paste from here if you want to test the complete command.</p>"},{"location":"guides/in_depth/#conclusion","title":"Conclusion","text":"<p>In this guide, you've seen how to:</p> <ul> <li>Structure commands using subcommands for better organization.</li> <li>Utilize the <code>tome_api.store.folder</code> for persistent data storage.</li> <li>Make your commands return data and use formatters for flexible text and   JSON output.</li> <li>Tested your command with different arguments and output formats using the   automatically provided <code>--format</code> option.</li> </ul> <p>These features allow you to build more sophisticated and user-friendly command-line tools with tome. Explore the Python Scripting API Reference for more details on these and other capabilities.</p>"},{"location":"guides/migrate_script/","title":"How to Migrate and Create Shell Scripts with Tome","text":"<p>If you have existing shell scripts or want to create new ones, you can easily integrate them into tome. tome can discover and run common shell script types (such as <code>.sh</code>, <code>.bash</code>, <code>.bat</code>, and <code>.ps1</code>) if they follow a few simple conventions:</p> <ul> <li>Filename Prefix: Scripts intended to be discovered by tome should have   their filenames prefixed with <code>tome_</code> (e.g., <code>tome_mybackup.sh</code>).</li> <li>Description Comment: Include a special comment line at or near the top of   your script: <code># tome_description: Your command description here</code> (use <code>REM   tome_description:</code> for <code>.bat</code> files).</li> <li>Directory Structure for Namespace: Place your script inside a   subdirectory. The name of this subdirectory will become the Namespace for   your command within its Tome.</li> </ul> <p>Let's walk through an example, starting by generating a shell script template with <code>tome new</code> and then customizing it.</p>"},{"location":"guides/migrate_script/#example-creating-a-networkping-shell-script-with-tome-new","title":"Example: Creating a <code>network:ping</code> Shell Script with <code>tome new</code>","text":"<p>We'll create a <code>ping</code> command in the <code>network</code> namespace that will be a shell script.</p>"},{"location":"guides/migrate_script/#step-1-generate-and-prepare-the-script","title":"Step 1: Generate and Prepare the Script","text":"<ol> <li> <p>First, create a directory that will serve as the Origin for this     Tome (e.g., <code>my-network-scripts</code>) and navigate into it.</p> <pre><code>$ mkdir my-network-scripts\n$ cd my-network-scripts\n</code></pre> </li> <li> <p>Use <code>tome new</code> with the <code>--type=sh</code> flag to generate a shell script template     for <code>network:ping</code>:</p> <pre><code>$ tome new network:ping --type=sh --description \"Pings an IP address or URL. Arguments: &lt;IP or URL&gt;\"\nGenerated script: network/tome_ping.sh\n</code></pre> <p>Your structure should now look like this:</p> <pre><code>my-network-scripts/\n\u2514\u2500\u2500 network/\n    \u2514\u2500\u2500 tome_ping.sh # This is the generated template\n</code></pre> </li> </ol>"},{"location":"guides/migrate_script/#step-2-customize-the-generated-script","title":"Step 2: Customize the Generated Script","text":"<p>The generated <code>network/tome_ping.sh</code> will contain a basic template. Open it and replace its content with the specific logic for our ping command:</p> <pre><code>#!/bin/bash\n# tome_description: Pings an IP address or URL. Arguments: &lt;IP or URL&gt;\n\nif [ \"$#\" -ne 1 ]; then\n    echo \"Usage: $0 &lt;IP or URL&gt;\"\n    exit 1\nfi\n\nping -c 4 \"$1\"\n</code></pre> <p>The description you provided to <code>tome new</code> (or edited in the file) will be shown by <code>tome list</code>. The script itself takes one argument (<code>$1</code>), which will be the IP or URL to ping.</p>"},{"location":"guides/migrate_script/#step-3-install-the-tome","title":"Step 3: Install the Tome","text":"<p>Navigate to your <code>my-network-scripts</code> directory (if you're not already there). Then, install it as an editable Tome:</p> <pre><code>$ tome install . -e\nConfigured editable installation ...\nInstalled source: ...\n</code></pre>"},{"location":"guides/migrate_script/#step-4-use-your-new-shell-command","title":"Step 4: Use Your New Shell Command","text":"<p>Now your shell script is a tome Command!</p> <p>List available commands (you might see others if you have more Tomes installed):</p> <pre><code>$ tome list\n</code></pre> <p>Output should include:</p> <pre><code>  \ud83c\udf10 network commands\n     network:ping-sh (e)  Pings an IP address or URL. Arguments: &lt;IP or URL&gt;\n</code></pre> <p>Note on Shell Command Naming: You might notice the command is listed as <code>network:ping-sh</code>. When tome discovers shell scripts (files not ending in <code>.py</code> but recognized as executable scripts like <code>.sh</code>, <code>.bat</code>, etc.), it often appends a suffix based on the script's extension (e.g., <code>-sh</code>, <code>-bat</code>) to the command name. This helps differentiate if you had, for example, both a Python and a shell version of a <code>ping</code> command in the same namespace. So, you'd run it as <code>tome network:ping-sh</code>.</p> <p>Run your command:</p> <pre><code>$ tome network:ping-sh 8.8.8.8\nPING 8.8.8.8 (8.8.8.8): 56 data bytes\n64 bytes from 8.8.8.8: icmp_seq=0 ttl=119 time=9.543 ms\n64 bytes from 8.8.8.8: icmp_seq=1 ttl=119 time=11.825 ms\n64 bytes from 8.8.8.8: icmp_seq=2 ttl=119 time=43.971 ms\n64 bytes from 8.8.8.8: icmp_seq=3 ttl=119 time=27.419 ms\n\n--- 8.8.8.8 ping statistics ---\n4 packets transmitted, 4 packets received, 0.0% packet loss\nround-trip min/avg/max/stddev = 9.543/23.189/43.971/13.831 ms\n</code></pre> <p>Arguments passed after <code>tome network:ping-sh</code> are forwarded directly to your <code>tome_ping.sh</code> script. Since it's an editable install, you can continue to modify <code>tome_ping.sh</code>, and the changes will be live immediately when you run it via tome.</p> <p>That's it! You've successfully created (by generating and then customizing) a shell script to be managed by tome. If you have an existing script, you would simply place it in the correct namespace folder, ensure it has the <code>tome_description</code> comment (and the <code>tome_</code> filename prefix if <code>tome new</code> didn't create it), and then install its parent Tome. This process applies to other shell script types like <code>.bat</code> or <code>.ps1</code> as well (using <code>REM tome_description:</code> for <code>.bat</code> files).</p>"},{"location":"guides/share/","title":"Sharing Your Tomes","text":"<p>Once you've created a Tome (your collection of scripts), you'll likely want to share it with your team, other users, or simply use it across different machines. tome makes this easy by supporting installation from various origins.</p>"},{"location":"guides/share/#supported-sharing-methods","title":"Supported Sharing Methods","text":""},{"location":"guides/share/#1-git-repositories","title":"1. Git Repositories","text":"<p>The most robust way to share and version your Tomes is by hosting them in a Git repository (like GitHub, GitLab, or a private server).</p> <ul> <li>How to share: Commit your Tome directory structure to a Git   repository. A typical structure might look like:</li> </ul> <pre><code>your-tome-repo\n\u251c\u2500\u2500 namespace_A\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 utility.py\n\u251c\u2500\u2500 namespace_B\n\u2502   \u251c\u2500\u2500 script1.py\n\u2502   \u2514\u2500\u2500 script2.sh\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 requirements.txt\n</code></pre> <p>Note on <code>.tomeignore</code>: It's a good practice to Include a <code>.tomeignore</code> file in your Tome's root to list files or patterns that tome should exclude during installation, much like a <code>.gitignore</code>. This prevents unwanted items (e.g., virtual environments, test artifacts, backups) from being included, ensuring only necessary files are processed. Each line in <code>.tomeignore</code> defines a pattern; lines starting with <code>#</code> are comments.</p> <pre><code># .tomeignore example\n*.log\ntemp_files/\n__pycache__/\n*.pyc\n.venv/\nmy_secret_backup.txt\n</code></pre> <ul> <li>How users install:   To install the default branch:</li> </ul> <pre><code>$ tome install https://github.com/your-user/your-tome-repo.git\n</code></pre> <p>They can also specify a particular branch, tag, or commit hash using the <code>@</code> symbol after the repository URL:</p> <ul> <li>Installing from a specific branch:       (e.g., to get scripts from a feature branch)</li> </ul> <pre><code>$ tome install https://github.com/your-user/your-tome-repo.git@my-feature-branch\n</code></pre> <ul> <li>Installing from a specific tag:       (e.g., to get a stable version like <code>v1.0.2</code>)</li> </ul> <pre><code>$ tome install https://github.com/your-user/your-tome-repo.git@v1.0.2\n</code></pre> <ul> <li>Installing from a specific commit hash:       (e.g., to get scripts exactly as they were at a particular point in history)</li> </ul> <pre><code>$ tome install https://github.com/your-user/your-tome-repo.git@a1b2c3d4e5f60708090a0b0c0d0e0f0a0b0c0d0e\n</code></pre>"},{"location":"guides/share/#2-local-folders","title":"2. Local Folders","text":"<p>For sharing within a team on a shared drive or for distributing scripts that are part of a larger local project:</p> <ul> <li> <p>How to share: Ensure the directory containing your Tome (with its   Namespace subdirectories) is accessible.</p> </li> <li> <p>How users install:</p> </li> </ul> <pre><code>$ tome install /path/to/shared/my-tome\n</code></pre> <p>Or, if they've copied it locally:</p> <pre><code>$ tome install ./my-local-copy-of-tome\n</code></pre>"},{"location":"guides/share/#3-zip-archives-and-other-compressed-files","title":"3. ZIP Archives (and other compressed files)","text":"<p>You can package your Tome into a ZIP file (or <code>.tar.gz</code>, etc.) for distribution.</p> <ul> <li>How to share: Create a compressed archive of your Tome directory.</li> <li> <p>How users install:</p> <ul> <li>From a local file:</li> </ul> <pre><code>$ tome install /path/to/my-tome.zip\n</code></pre> <ul> <li>From a URL:</li> </ul> <pre><code>$ tome install https://example.com/my-tome.zip\n</code></pre> </li> </ul>"},{"location":"guides/share/#installing-from-a-subfolder-folder-option","title":"Installing from a Subfolder (<code>--folder</code> Option)","text":"<p>If your actual scripts within a Git repository or ZIP file are located in a subdirectory (not at the root of the repository/archive), users can point tome to it using the <code>--folder</code> flag during installation:</p> <pre><code>$ tome install &lt;git_or_zip_source&gt; --folder path/to/scripts_within_source\n</code></pre> <p>For example, if your scripts are in an <code>src/</code> folder inside your Git repository:</p> <pre><code>$ tome install https://github.com/your-user/your-tome-repo.git --folder src\n</code></pre>"},{"location":"guides/testing/","title":"Testing Your Scripts","text":"<p>Writing tests for your tome Commands is crucial for ensuring they behave as expected and for maintaining them over time. tome leverages <code>pytest</code> for its testing capabilities.</p> <p>Prerequisites for Testing:</p> <ul> <li>Make sure <code>pytest</code> is installed in your Python virtual environment:</li> </ul> <pre><code>$ pip install pytest\n</code></pre> <ul> <li>Your Tome (the one containing the Scripts and their corresponding   <code>tests</code> directories) must be installed via <code>tome install</code> (either normally or   with the <code>-e</code> flag for editable installs).</li> </ul>"},{"location":"guides/testing/#initial-test-setup","title":"Initial Test Setup","text":"<p>When you create a new Python-based Command using <code>tome new &lt;namespace&gt;:&lt;commandname&gt;</code>, tome automatically generates not only the script file but also a corresponding test file.</p> <p>Let's see an example. Suppose you run:</p> <pre><code>$ mkdir my-tome\n$ cd my-tome\n$ tome new greet:hello --description \"A friendly greeting command.\"\nGenerated script: greet/hello.py\n</code></pre> <p>This will create the following directory structure within <code>my-tome/</code>:</p> <pre><code>my-tome/\n\u2514\u2500\u2500 greet/\n    \u251c\u2500\u2500 hello.py           # Your command script\n    \u2514\u2500\u2500 tests/             # Directory for tests\n        \u2514\u2500\u2500 test_hello.py  # Basic test file for hello.py\n</code></pre> <p>As you can see, a <code>tests</code> subdirectory is created within your <code>greet</code> Namespace folder, containing <code>test_hello.py</code>.</p> <p>The generated <code>greet/hello.py</code> (based on your project's template) might include a helper function, for instance, <code>frog_hello</code> for formatting the output with an ASCII frog. The corresponding <code>greet/tests/test_hello.py</code> would then have a basic test for that helper:</p> <pre><code># greet/tests/test_hello.py\nfrom greet.hello import frog_hello\n\ndef test_frog_hello_formatting():\n    \"\"\"\n    Test the basic formatting of the frog_hello function\n    from greet:hello.\n    \"\"\"\n    message = \"Test Message\"\n    output = frog_hello(message)\n\n    assert f\"&lt; {message.ljust(len(message))} &gt;\" in output\n    assert \" __\" in output\n    assert \" --\" in output\n    assert r\"        \\\\   @..@\" in output\n    assert r\"         \\\\ (----)\" in output\n    assert r\"           ( &gt;__&lt; )\" in output\n    assert r\"           ^^ ~~ ^^\" in output\n</code></pre> <ul> <li>Note: The content of <code>test_hello.py</code> above, especially the <code>frog_hello</code> import and the assertions, are based on the \"ASCII frog\" example from your <code>tome new</code> template seen in <code>docs/index.md</code> and <code>tome/commands/new.py</code>. Ensure this example test aligns with the actual test file your <code>tome new</code> command currently generates. If it generates a different helper or test, update this example accordingly.</li> </ul>"},{"location":"guides/testing/#running-tests-with-tome-test","title":"Running Tests with <code>tome test</code>","text":"<p>The <code>tome test</code> Tome Command is your primary tool for running tests. It discovers and executes <code>pytest</code> tests for your installed Tomes.</p> <ul> <li> <p>Test a Specific Command: If you want to run tests associated with a     particular Command (e.g., tests in <code>greet/tests/test_hello.py</code> for the     <code>greet:hello</code> command):</p> <pre><code>$ tome install . -e  # Ensure your Tome is installed\n$ tome test greet:hello\n</code></pre> </li> <li> <p>Test All Commands in a Namespace: To run all tests for Commands     within the <code>greet</code> Namespace:</p> <pre><code>$ tome test greet:*\n</code></pre> </li> <li> <p>Test All Commands in All Installed Tomes: (This applies to Tomes     installed from the cache or in editable mode)</p> <pre><code>$ tome test \"*\"\n</code></pre> </li> </ul>"},{"location":"guides/features/store/","title":"Persistent Data Storage with Tome Store","text":"<p>Many tome Commands need to save information between runs \u2013 perhaps user preferences, cached data, logs, or application-specific files. Instead of hardcoding file paths or scattering data across the user's system, tome provides a dedicated Store feature for this purpose.</p> <p>The <code>tome_api</code> object, passed to your Python command functions, has an attribute <code>tome_api.store.folder</code>. This attribute contains the absolute path to a directory within the tome home (typically <code>~/.tome/storage/</code>) where your scripts can reliably read and write files.</p>"},{"location":"guides/features/store/#how-to-use-tome_apistorefolder","title":"How to Use <code>tome_api.store.folder</code>","text":"<p>Let's illustrate with an example. Imagine a command that counts how many times it has been executed.</p>"},{"location":"guides/features/store/#example-a-simple-execution-counter","title":"Example: A Simple Execution Counter","text":"<p>We'll create a command <code>stats:runcount</code> that increments a counter each time it's run and displays the current count.</p> <p>Setup the Script: First, create the script using <code>tome new</code>:</p> <pre><code>$ mkdir my-tome\n$ cd my-tome\n$ tome new stats:runcount --description \"Counts times it has been run.\"\n$ tome install . -e\n</code></pre> <p>Implement <code>stats/runcount.py</code>:</p> <pre><code># stats/runcount.py\nfrom tome.command import tome_command\nfrom tome.api.output import TomeOutput\nimport json\nimport os\n\nCOUNTER_FILENAME = \"run_counter.json\"\n\n@tome_command()\ndef runcount(tome_api, parser, *args):\n    \"\"\"Counts times it has been run.\"\"\"\n    parsed_args = parser.parse_args(*args) # Process any potential future args\n    output = TomeOutput(stdout=True)\n\n    # Define a path for this command's data within the tome store\n    command_storage_dir = os.path.join(tome_api.store.folder, \"stats_runcount\")\n    os.makedirs(command_storage_dir, exist_ok=True) # Ensure the directory exists\n    counter_file_path = os.path.join(command_storage_dir, COUNTER_FILENAME)\n\n    count = 0\n    # Load existing count\n    if os.path.exists(counter_file_path):\n        try:\n            with open(counter_file_path, 'r') as f:\n                data = json.load(f)\n                count = data.get(\"run_count\", 0)\n        except (IOError, json.JSONDecodeError):\n            # If file is corrupt or unreadable, start count from 0\n            TomeOutput().warning(f\"Could not read counter file, resetting count.\")\n            count = 0\n\n    # Increment count\n    count += 1\n\n    # Save new count\n    try:\n        with open(counter_file_path, 'w') as f:\n            json.dump({\"run_count\": count}, f)\n        output.info(f\"This command has been run {count} time(s).\")\n        output.info(f\"(Counter data stored in: {counter_file_path})\")\n    except IOError as e:\n        TomeOutput().error(f\"Could not save run count: {e}\")\n        output.info(f\"Current run (not saved) would be #{count}.\")\n</code></pre> <p>Running the Command: Each time you run the command, the count should increment:</p> <pre><code>$ tome stats:runcount\nThis command has been run 1 time(s).\n(Counter data stored in: /&lt;tome_home&gt;/storage/stats_runcount/run_counter.json)\n\n$ tome stats:runcount\nThis command has been run 2 time(s).\n(Counter data stored in: /&lt;tome_home&gt;/storage/stats_runcount/run_counter.json)\n\n$ tome stats:runcount\nThis command has been run 3 time(s).\n(Counter data stored in: /&lt;tome_home&gt;/storage/stats_runcount/run_counter.json)\n</code></pre> <p>You can inspect the <code>run_counter.json</code> file in the specified path to see the stored count.</p>"},{"location":"guides/features/store/#best-practices-for-using-the-store-api","title":"Best Practices for Using the Store API","text":"<ul> <li>Organize with Subdirectories: As shown, create subdirectories within   <code>tome_api.store.folder</code> (e.g., based on your Namespace and/or Command   name like <code>os.path.join(tome_api.store.folder, \"your_namespace\",   \"your_command\")</code>). This prevents file naming conflicts if multiple Tomes   or Commands use the store.</li> <li>Handle File I/O Errors: Always wrap file operations (reading, writing) in   <code>try...except IOError</code> blocks to manage potential issues gracefully.</li> <li>Inform Users (If Necessary): If your command stores significant data or   user-configurable files, consider documenting where this data is located   (i.e., within the tome store) so users can understand, manage, or back it   up if needed.</li> </ul>"},{"location":"guides/features/vault/","title":"Using Tome Vault for Secrets Management","text":"<p>Many scripts require access to sensitive information like API keys, database passwords, or private tokens. Storing these directly in scripts is a security risk. tome's Vault feature provides a secure, local, and encrypted store for this data, accessible only with a master password.</p>"},{"location":"guides/features/vault/#core-vault-concepts","title":"Core Vault Concepts","text":"<ul> <li>Vault: Your encrypted local datastore for secrets. You can have multiple   named vaults (default is <code>default</code>).</li> <li>Secret: An individual piece of sensitive data (e.g., an API key) stored in   a Vault under a specific name.</li> <li>Password: The master password for a Vault. Remember it! Losing it   means losing access to the secrets within.</li> </ul>"},{"location":"guides/features/vault/#create-a-script-that-needs-a-secret","title":"Create a Script That Needs a Secret","text":"<p>Let's start by creating a new tome Command. Imagine we want a script that fetches some data using an API, and this API requires an access token.</p> <ol> <li>Create a project directory and navigate into it:</li> </ol> <pre><code>$ mkdir my-tome\n$ cd my-tome\n</code></pre> <ol> <li>Use <code>tome new</code> to create a script. We'll call it <code>getdata</code> in the     <code>dataservice</code> namespace:</li> </ol> <pre><code>$ tome new dataservice:getdata --description \"Fetches data from some service.\"\nGenerated script: dataservice/getdata.py\n</code></pre> <ol> <li>Now, let's edit <code>dataservice/getdata.py</code>. We'll make it try to access a     secret named <code>api_token</code> from the <code>default</code> vault.</li> </ol> <pre><code># dataservice/getdata.py\nfrom tome.command import tome_command\nfrom tome.api.output import TomeOutput\nfrom tome.errors import TomeException\n\n@tome_command()\ndef getdata(tome_api, parser, *args):\n    \"\"\"\n    Fetches data from some service.\n    \"\"\"\n    parser.add_argument(\n        '--vault-password',\n        help=\"Password for the 'default' vault (will prompt if not provided)\"\n    )\n    # In a real script, you might have other arguments like --endpoint, etc.\n    parsed_args = parser.parse_args(*args)\n\n    output = TomeOutput(stdout=True)\n    error_output = TomeOutput() # For errors, to stderr\n\n    # Attempt to open the 'default' vault\n    default_vault = tome_api.vault.open(name='default', password=parsed_args.vault_password)\n\n    api_token = default_vault.read(name='api_token')\n\n    if api_token:\n        output.info(f\"Simulating API call...\")\n        # Here, you would use the api_token to make your actual API request\n        output.info(\"Data fetched successfully!\")\n    else:\n        error_output.warning(\"Could not retrieve 'api_token'. Is it set in the 'default' vault?\")\n</code></pre> <p>Important elements:</p> <ul> <li>The script defines a <code>--vault-password</code> argument to potentially receive the   vault password, though <code>tome_api.vault.open()</code> will prompt if it's not   supplied and needed.</li> <li>It directly calls <code>tome_api.vault.open(name='default',   password=parsed_args.vault_password)</code> to access the <code>default</code> vault. If the   vault doesn't exist or the password (if prompted or provided) is incorrect,   tome itself will typically raise an error.</li> <li>It then attempts to read a secret named <code>api_token</code> using   <code>default_vault.read(name='api_token')</code>.</li> <li> <p>Based on whether <code>api_token</code> is found, it prints a success simulation or a   warning. Note that direct error handling for vault operations (like a wrong   password for an existing vault) is not explicitly in this simplified script   version; tome would handle such errors.</p> </li> <li> <p>Install this Tome as editable:</p> </li> </ul> <pre><code>$ tome install . -e\nConfigured editable installation for /path/to/my-tome\nInstalled source: /path/to/my-tome\n</code></pre>"},{"location":"guides/features/vault/#step-2-first-attempt-the-expected-failure","title":"Step 2: First Attempt - The Expected Failure","text":"<p>If you try to run this command now, and you haven't set up any vaults or secrets, it will likely fail or indicate that the secret is missing.</p> <pre><code>$ tome dataservice:getdata --vault-password mydummy_pass_for_now\nError: Vault 'default' does not exist. Please run 'tome vault create' to create it first.\n</code></pre> <p>This is expected! Our script is trying to access a vault and a secret that don't exist yet.</p>"},{"location":"guides/features/vault/#step-3-setting-up-the-vault-and-secret","title":"Step 3: Setting Up the Vault and Secret","text":"<p>Now, let's use the <code>tome vault</code> CLI commands to create our <code>default</code> vault and add the <code>api_token</code> secret.</p> <ol> <li>Create the <code>default</code> vault: You'll be prompted to set a new password for     this vault. Choose a secure password and remember it.</li> </ol> <pre><code>$ tome vault create\nTome vault password: mydummy_pass_for_now\nConfirm tome vault password: mydummy_pass_for_now\nVault 'default' created\n</code></pre> <ol> <li>Add the <code>api_token</code> secret to the <code>default</code> vault: You'll be prompted     for the vault password you just set.</li> </ol> <pre><code>$ tome vault add-secret api_token \"SecretToken\" --description \"Access token\"\nTome vault password: mydummy_pass_for_now\nSecret 'api_token' added to 'default' vault.\n</code></pre> <pre><code>You can verify the secret name is listed (the value itself remains\nencrypted):\n</code></pre> <pre><code>$ tome vault list-secrets\nVault 'default' secrets:\napi_token         Access token\n</code></pre>"},{"location":"guides/features/vault/#step-4-running-the-script-successfully","title":"Step 4: Running the Script Successfully","text":"<p>Now that the <code>default</code> vault exists and contains the <code>api_token</code> secret, let's run our <code>dataservice:getdata</code> command again. This time, provide the correct vault password you set.</p> <pre><code>$ tome dataservice:getdata --vault-password mydummy_pass_for_now\nSimulating API call...\nData fetched successfully!\n</code></pre> <p>Success! Your script now securely accesses the API token from the tome Vault.</p>"},{"location":"guides/features/vault/#step-5-cleaning-up-deleting-the-secret","title":"Step 5: Cleaning Up - Deleting the Secret","text":"<p>Once you are done with a secret, or if it was created for testing purposes, you can remove it from the vault. To delete the <code>api_token</code> we created earlier from the <code>default</code> vault, use the <code>tome vault delete-secret</code> command.</p> <p>You will be prompted for the vault password:</p> <pre><code>$ tome vault delete-secret api_token\nTome vault password: &lt;enter_your_secure_password_here&gt;\nSecret 'api_token' deleted from 'default' vault.\n</code></pre> <p>You can confirm it's gone by listing the secrets again:</p> <pre><code>$ tome vault list-secrets\nNo secrets found.\n</code></pre>"},{"location":"guides/features/vault/#conclusion","title":"Conclusion","text":"<p>In this guide, you've learned the essentials of tome's Vault feature:</p> <ul> <li>How to write a Python Command that attempts to read a secret.</li> <li>The importance of creating a Vault and adding Secrets to it using   <code>tome vault</code> CLI commands.</li> <li>How your script can successfully retrieve and use these stored secrets once   the vault is set up.</li> <li>How to clean up by deleting secrets.</li> </ul>"},{"location":"overview/","title":"Overview","text":"<p>This section is your primary starting point for understanding what tome is, how to get it set up, and how to quickly see it in action.</p> <p>Here you'll find:</p> <ul> <li>Installation: Get tome installed on your system.</li> <li>Quickstart: A hands-on tutorial to create and run your   first tome command.</li> <li>Help &amp; Support: Learn how to use tome's built-in help and   find other support channels.</li> </ul>"},{"location":"overview/help/","title":"Help &amp; Support","text":"<p>If you need assistance while using tome, there are several ways to get help directly from the command line. For other issues, feature requests, or if you're interested in contributing, our GitHub repository is the place to go.</p>"},{"location":"overview/help/#using-built-in-cli-help","title":"Using Built-in CLI Help","text":"<p>tome includes a helpful command-line interface to guide you.</p>"},{"location":"overview/help/#general-command-overview","title":"General Command Overview","text":"<p>To see a list of all available tome commands and their brief descriptions, run:</p> <pre><code>$ tome --help\n</code></pre> <p>This will typically output something like:</p> <pre><code>\ud83d\udcd6 tome commands:\n  config         Manage the tome configuration.\n  info           Get information about a specific command.\n  install        Install scripts from a source.\n  list           List all the commands that match a given pattern.\n  new            Create a new example recipe and source files from a template.\n  test           Run any test located by your script with pytest framework.\n  uninstall      Uninstall a tome of scripts.\n  vault          Manage encrypted secret variables usable in any tome script.\n\nType 'tome &lt;command&gt; -h' for help\n</code></pre>"},{"location":"overview/help/#help-for-specific-commands","title":"Help for Specific Commands","text":"<p>If you need help with a particular command, its options, and arguments, you can use the <code>--help</code> (or <code>-h</code>) flag after the command name.</p> <p>For example, to get help for the <code>install</code> command:</p> <pre><code>$ tome install --help\n</code></pre> <p>This will show detailed usage information, similar to this:</p> <pre><code>usage: tome install [-h] [-v] [-q] [-f FORMAT] [-e] [--no-ssl] [--create-env] [--force-requirements] [--folder FOLDER] [source]\n\nInstall scripts from a source.\n\n    The source can be a git repository, a folder, or a zip file (local or http).\n    Editable installations are supported with the -e/--editable flag.\n\npositional arguments:\n    source                Source: a git repository, folder, or zip file (local or http).\n\noptions:\n    -h, --help            show this help message and exit\n    -v, --verbose         Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n    -q, --quiet           Reduce the output to a minimum, showing only critical errors\n    -f FORMAT, --format FORMAT\n                        Select the output format: json\n    -e, --editable        Install a package in editable mode.\n    --no-ssl              Do not verify SSL connections.\n    --create-env          Create a new virtual environment if the command depends on any requirements.\n    --force-requirements  Install requirements even if not running tome in a virtual environment.\n    --folder FOLDER       Specify a folder within the source to install from (only valid for git or zip file sources).\n</code></pre> <p>This detailed help is available for all tome commands and their subcommands.</p>"},{"location":"overview/help/#checking-the-tome-version","title":"Checking The tome Version","text":"<p>To quickly check the installed version of tome, you can use the <code>--version</code> flag:</p> <pre><code>$ tome --version\n0.2.0\n</code></pre>"},{"location":"overview/help/#further-assistance","title":"Further Assistance","text":""},{"location":"overview/help/#reporting-issues-or-requesting-features","title":"Reporting Issues or Requesting Features","text":"<p>If you've found a bug, are facing a problem not covered in the documentation, or have an idea for a new feature, please let us know by opening an issue on our GitHub repository.</p>"},{"location":"overview/help/#contributing-to-tome","title":"Contributing to tome","text":"<p>We welcome contributions! If you're interested in helping improve tome, please check out our contributing guide.</p>"},{"location":"overview/installing/","title":"Installing tome","text":""},{"location":"overview/installing/#install-from-pypi","title":"Install from PyPI","text":"<p>tome is published to PyPi. The recommended way to install tome is using <code>pip</code> within a virtual environment. This ensures that your project dependencies are isolated and managed effectively:</p> <ul> <li>Create a virtual environment:</li> </ul> <pre><code>$ python -m venv myenv\n</code></pre> <ul> <li>Activate the virtual environment:</li> </ul> UNIX/macOSWindows <pre><code>$ source myenv/bin/activate\n</code></pre> <pre><code>$ myenv\\Scripts\\activate\n</code></pre> <ul> <li>Install tome using <code>pip</code>:</li> </ul> <pre><code>$ pip install tomescripts\n</code></pre> <p>Now you can start using tome</p>"},{"location":"overview/installing/#install-from-source-as-editable","title":"Install from source as editable","text":"<p>For instructions on how to install tome as editable, please refer to the contributing guide.</p>"},{"location":"overview/quickstart/","title":"Quickstart: Your First 5 Minutes with Tome","text":"<p>This guide will get you from zero to running your own commands in about 5 minutes. We'll create a simple script, install it with tome as editable so we can make live changes to it and run it.</p> <p>Throughout this guide, you will encounter several terms specific to tome. For detailed definitions, we invite you to review our Glossary.</p>"},{"location":"overview/quickstart/#step-1-initialize-your-script-collection-your-tome","title":"Step 1: Initialize Your Script Collection (Your \"Tome\")","text":"<p>First, let's create a dedicated directory for our scripts. This directory will represent your personal Tome or collection of scripts.</p> <pre><code>$ mkdir my-scripts\n$ cd my-scripts\n</code></pre> <p>Next, we'll use tome to scaffold a new script. We'll create a script named <code>agecalc.py</code> in the <code>utils</code> namespace. This script will define the <code>utils:agecalc</code> command, which calculates your age based on your birth date.</p> <pre><code>$ tome new utils:agecalc\nGenerated script: utils/agecalc.py\n</code></pre> <p>This command will generate a couple of files:</p> <ul> <li><code>utils/agecalc.py</code>: The Python file for your script containing the definition of the <code>utils:agecalc</code> command.</li> <li><code>utils/tests/test_agecalc.py</code>: A basic test file.</li> </ul> <p>Your <code>my-scripts</code> directory will look like this:</p> <pre><code>my-scripts/\n\u2514\u2500\u2500 utils/\n    \u251c\u2500\u2500 agecalc.py\n    \u2514\u2500\u2500 tests/\n        \u2514\u2500\u2500 test_agecalc.py\n</code></pre>"},{"location":"overview/quickstart/#step-2-customize-your-new-script","title":"Step 2: Customize Your New Script","text":"<p>Open the generated <code>utils/agecalc.py</code> file in your favorite text editor. Let's modify the default template to implement our age calculator.</p> <pre><code>from tome.command import tome_command\nfrom tome.api.output import TomeOutput\nfrom tome.errors import TomeException\n\nimport datetime\n\n@tome_command()\ndef agecalc(tome_api, parser, *args):\n    \"\"\"\n    Calculates age based on a given birth date.\n    \"\"\"\n    parser.add_argument(\n        'birthdate',\n        type=str,\n        help=\"Your birth date in YYYY-MM-DD format (e.g., '1990-07-25')\"\n    )\n    parsed_args = parser.parse_args(*args)\n\n    try:\n        birth_date_obj = datetime.datetime.strptime(parsed_args.birthdate, '%Y-%m-%d').date()\n    except ValueError:\n        raise TomeException(\"Invalid date format. Please use YYYY-MM-DD.\")\n\n    today = datetime.date.today()\n    age_years = today.year - birth_date_obj.year - ((today.month, today.day) &lt; (birth_date_obj.month, birth_date_obj.day))\n\n    TomeOutput(stdout=True).info(f\"You are {age_years} years old.\")\n</code></pre> <p>Script Breakdown:</p> <ul> <li> <p><code>@tome_command()</code>:   This decorator before your <code>agecalc</code> function, is how you register it with   tome. It essentially tells tome to make this function runnable as the   <code>utils:agecalc</code> command. It's the main way tome discovers your   Python-based commands.</p> </li> <li> <p>Command Function Signature: The <code>agecalc</code> function, like all tome Python commands, takes <code>tome_api</code>, <code>parser</code>, and <code>*args</code> as parameters.</p> <ul> <li><code>tome_api</code>: Provides access to tome's features (not used in this   simple version).</li> <li><code>parser</code>: An <code>argparse.ArgumentParser</code> instance provided by tome for   defining command-line arguments.</li> <li><code>*args</code>: The arguments passed to your command.</li> </ul> </li> <li> <p>Argument Parsing: We use <code>parser.add_argument(...)</code>. This is standard   Python <code>argparse</code> functionality.</p> </li> <li> <p>Output with <code>TomeOutput</code>: For now, <code>TomeOutput(stdout=True).info()</code> prints   directly. Notice the <code>stdout=True</code>, by default all output via <code>TomeOutput</code>   goes to <code>stderr</code>, so we specify that we want the result message of our command   in <code>stdout</code>.</p> </li> <li> <p>Error Handling with <code>TomeException</code>:   Notice the <code>try...except</code> block. If the date format is invalid, instead of   just printing an error, we <code>raise TomeException(\"Invalid date format...\")</code>.   This is the recommended way to signal errors from your commands. tome will   catch this exception and display the error message to the user in a   standardized way, also ensuring the command exits with an error status.</p> </li> </ul> <p>Save the changes to <code>utils/agecalc.py</code>.</p>"},{"location":"overview/quickstart/#step-3-install-your-local-tome","title":"Step 3: Install Your Local \"Tome\"","text":"<p>For tome to recognize and run scripts from your <code>my-scripts</code> directory, you need to \"install\" this Tome. We'll use an editable install (<code>-e</code>) so any further changes to your scripts are picked up automatically.</p> <p>From inside the <code>my-scripts</code> directory, run:</p> <pre><code>$ tome install . -e\nConfigured editable installation ...\nInstalled source ...\n</code></pre>"},{"location":"overview/quickstart/#step-4-run-your-new-command","title":"Step 4: Run Your New Command!","text":"<p>Now you can execute your <code>agecalc</code> script:</p> <pre><code>$ tome utils:agecalc 1990-07-25\nYou are 34 years old.\n</code></pre>"},{"location":"overview/quickstart/#step-5-see-your-command-listed","title":"Step 5: See Your Command Listed","text":"<p>Check all available commands with <code>tome list</code>:</p> <pre><code>$ tome list utils\n\n\ud83d\udcd6 /some/path/my-scripts\n\n  \ud83d\udc2e utils commands\n     utils:agecalc (e)  Calculates age based on a given birth date.\n</code></pre> <p>The <code>(e)</code> reminds you it's an editable installation.</p>"},{"location":"overview/quickstart/#thats-it","title":"That's It!","text":"<p>Congratulations! You've successfully navigated the core workflow of creating a tome command:</p> <ul> <li>Used <code>tome new</code> to scaffold a Python Script within a Namespace.</li> <li>Defined a Command with command-line arguments using <code>argparse</code>.</li> <li>Implemented basic error handling using <code>TomeException</code>.</li> <li>Installed your local directory as an editable Tome.</li> </ul>"},{"location":"overview/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've seen the basics, you're ready to explore more:</p> <ul> <li>Deepen your knowledge: Explore the User Guides,   starting with \"Tome Scripts In-Depth\" to learn about   subcommands, formatting output, script migration and managing Tomes.</li> <li>API Specifics: For detailed information on the <code>@tome_command</code> decorator,   command function signatures, or the <code>TomeOutput</code> class, see the Python   Scripting API Reference.</li> <li>Command Details: For a full list of tome's own built-in commands and   all their options, refer to the CLI Reference.</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>This section is intended for users who want to understand the specific options for each command or the technical details of how to write and integrate scripts with tome:</p> <ul> <li> <p>Command-Line Interface (CLI): An exhaustive reference for all   built-in <code>tome</code> commands, their arguments, and options.</p> </li> <li> <p>Python Scripting API: Detailed documentation for   developers on how to create tome commands using Python, including   decorators, function signatures, and output formatting.</p> </li> </ul>"},{"location":"reference/cli/","title":"Command-Line Interface (CLI) Reference","text":"<p>This page provides a comprehensive reference for all built-in Tome Commands.</p> <p>For quick help from your terminal, you can always use:</p> <ul> <li>General help and list of commands: <code>tome --help</code></li> <li>Help for a specific command: <code>tome &lt;command_name&gt; --help</code></li> <li>Help for a subcommand: <code>tome &lt;command_name&gt; &lt;subcommand_name&gt; --help</code></li> </ul> <p>Global options available for most commands:</p> <ul> <li><code>-v, --verbose</code>: Increase the level of verbosity (can be used multiple times,   e.g., <code>-vv</code>, <code>-vvv</code>).</li> <li><code>-q, --quiet</code>: Reduce the output to a minimum, showing only critical errors.</li> </ul>"},{"location":"reference/cli/#tome-general-usage","title":"<code>tome</code> (General Usage)","text":"<p>Running <code>tome</code> without any arguments or with just <code>--help</code> provides a list of all top-level available commands.</p> <pre><code>$ tome --help\n\n\ud83d\udcd6 tome commands:\n  config         Manage the tome configuration.\n  info           Get information about a specific command.\n  install        Install scripts from a source.\n  list           List all the commands that match a given pattern.\n  new            Create a new example recipe and source files from a template.\n  test           Run any test located by your script with pytest framework.\n  uninstall      Uninstall a tome of scripts.\n  vault          Manage encrypted secret variables usable in any tome script.\n</code></pre>"},{"location":"reference/cli/#tome-config","title":"<code>tome config</code>","text":"<p>Manages tome configuration settings, such as the home directory and storage path. This command has subcommands to query specific configuration values.</p> <p>Usage:</p> <pre><code>$ tome config --help\n\nusage: tome config [-h] [-v] [-q] {home,store} ...\n\nManage the tome configuration.\n\npositional arguments:\n  {home,store}    sub-command help\n    home          print the current home folder\n    store         print the current store folder\n\noptions:\n  -h, --help      show this help message and exit\n  -v, --verbose   Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet     Reduce the output to a minimum, showing only critical errors\n</code></pre>"},{"location":"reference/cli/#tome-config-home","title":"<code>tome config home</code>","text":"<p>Prints the absolute path to the current tome home directory. This is the root directory where tome stores its cache, installed scripts, vaults, and other operational data.</p> <p>Usage:</p> <pre><code>$ tome config home --help\n\nusage: tome config home [-h] [-v] [-q]\n\noptions:\n  -h, --help      show this help message and exit\n  -v, --verbose   Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet     Reduce the output to a minimum, showing only critical errors\n</code></pre>"},{"location":"reference/cli/#tome-config-store","title":"<code>tome config store</code>","text":"<p>Prints the absolute path to tome's local storage directory. Scripts managed by tome can use this location to persist their own data, like configuration files or caches.</p> <p>Usage:</p> <pre><code>$ tome config store --help\n\nusage: tome config store [-h] [-v] [-q]\n\noptions:\n  -h, --help      show this help message and exit\n  -v, --verbose   Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet     Reduce the output to a minimum, showing only critical errors\n</code></pre>"},{"location":"reference/cli/#tome-info","title":"<code>tome info</code>","text":"<p>Retrieves and displays detailed information about a specific installed Command.</p> <p>Usage:</p> <pre><code>$ tome info --help\n\nusage: tome info [-h] [-v] [-q] [-f FORMAT] command_name\n\nGet information about a specific command.\n\npositional arguments:\n  command_name          The full name of the command (e.g., namespace:command).\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --verbose         Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet           Reduce the output to a minimum, showing only critical errors\n  -f FORMAT, --format FORMAT\n                        Select the output format: json\n</code></pre>"},{"location":"reference/cli/#tome-install","title":"<code>tome install</code>","text":"<p>Installs a Tome (collection of scripts) from a specified Origin, making its Commands discoverable and executable by tome.</p> <p>Usage:</p> <pre><code>$ tome install --help\n\nusage: tome install [-h] [-v] [-q] [-f FORMAT] [-e] [--no-ssl] [--create-env]\n                      [--force-requirements] [--folder FOLDER]\n                      [source]\n\nInstall scripts from a source.\n\n    The source can be a git repository, a folder, or a zip file (local or http).\n    Editable installations are supported with the -e/--editable flag.\n\npositional arguments:\n  source                Source: a git repository, folder, or zip file (local or http).\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --verbose         Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet           Reduce the output to a minimum, showing only critical errors\n  -f FORMAT, --format FORMAT\n                        Select the output format: json\n  -e, --editable        Install a package in editable mode.\n  --no-ssl              Do not verify SSL connections.\n  --create-env          Create a new virtual environment if the command depends on any requirements.\n  --force-requirements  Install requirements even if not running tome in a virtual environment.\n  --folder FOLDER       Specify a folder within the source to install from (only valid for git or zip file sources).\n</code></pre>"},{"location":"reference/cli/#tome-list","title":"<code>tome list</code>","text":"<p>Lists all installed Commands that tome is aware of, optionally filtered by a pattern.</p> <p>Usage:</p> <pre><code>$ tome list --help\n\nusage: tome list [-h] [-v] [-q] [-f FORMAT] [pattern]\n\nList all the commands that match a given pattern.\n\npositional arguments:\n  pattern               Commands name pattern. By default, it shows all the commands\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --verbose         Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet           Reduce the output to a minimum, showing only critical errors\n  -f FORMAT, --format FORMAT\n                        Select the output format: json\n</code></pre>"},{"location":"reference/cli/#tome-new","title":"<code>tome new</code>","text":"<p>Creates a new example Script (and associated test files for Python scripts) from a template, placing it within the specified Namespace.</p> <p>Usage:</p> <pre><code>$ tome new --help\n\nusage: tome new [-h] [-v] [-q] [--type {python,sh,bat}] [--script SCRIPT] [-f]\n                  [--description DESCRIPTION]\n                  script_name\n\nCreate a new example recipe and source files from a template.\n\npositional arguments:\n  script_name           Name for the script in a tome standard way, like namespace:script_name.\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --verbose         Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet           Reduce the output to a minimum, showing only critical errors\n  --type {python,sh,bat}\n                        Type of the script to create.\n  --script SCRIPT       Content of the script if type is 'sh' or 'bat'.\n  -f, --force           Force overwrite of command if it already exists\n  --description DESCRIPTION\n                        Description of the command.\n</code></pre>"},{"location":"reference/cli/#tome-test","title":"<code>tome test</code>","text":"<p>Runs tests for your installed Tomes using the <code>pytest</code> framework. tome will look for test files (typically <code>test_*.py</code> or <code>*_test.py</code>) within the directories of the Tomes that match your pattern.</p> <p>Usage:</p> <pre><code>$ tome test --help\n\nusage: tome test [-h] [-v] [-q] pattern\n\nRun any test located by your script with pytest framework.\n\npositional arguments:\n  pattern               Commands name pattern. Use '*' to launch all tests or 'namespace:command' to launch tests for a specific command.\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --verbose         Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet           Reduce the output to a minimum, showing only critical errors\n</code></pre>"},{"location":"reference/cli/#tome-uninstall","title":"<code>tome uninstall</code>","text":"<p>Uninstalls a Tome from tome's management, based on its Origin.</p> <p>Usage:</p> <pre><code>$ tome uninstall --help\n\nusage: tome uninstall [-h] [-v] [-q] [-f FORMAT] [source]\n\nUninstall a tome of scripts.\n\npositional arguments:\n  source                Source: a git repository, folder, or zip file (local or http).\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --verbose         Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet           Reduce the output to a minimum, showing only critical errors\n  -f FORMAT, --format FORMAT\n                        Select the output format: json\n</code></pre>"},{"location":"reference/cli/#tome-vault","title":"<code>tome vault</code>","text":"<p>Manages encrypted secret variables that can be used by your tome Commands. This command has several subcommands for creating vaults, adding/removing secrets, and listing secrets.</p> <p>Usage:</p> <pre><code>$ tome vault --help\n\nusage: tome vault [-h] [-v] [-q]\n                  {create,delete,add-secret,delete-secret,list-secrets} ...\n\nManage encrypted secret variables usable in any tome script.\n\npositional arguments:\n  {create,delete,add-secret,delete-secret,list-secrets}\n                        sub-command help\n    create              Create a new vault with a new password\n    delete              Delete a vault\n    add-secret          Add a new secret\n    delete-secret       Delete a secret\n    list-secrets        List available secrets id's and descriptions in all vaults\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --verbose         Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet           Reduce the output to a minimum, showing only critical errors\n</code></pre>"},{"location":"reference/cli/#tome-vault-create","title":"<code>tome vault create</code>","text":"<p>Creates a new encrypted vault. You will be prompted for a password to secure it.</p> <p>Usage:</p> <pre><code>$ tome vault create --help\n\nusage: tome vault create [-h] [-v] [-q] [-f FORMAT] [-p PASSWORD] [-n NAME]\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --verbose         Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet           Reduce the output to a minimum, showing only critical errors\n  -f FORMAT, --format FORMAT\n                        Select the output format: json\n  -p PASSWORD, --password PASSWORD\n                        Tome vault password (Prompt if not specified)\n  -n NAME, --name NAME  Vault name (will use the \"default\" vault if not specified)\n</code></pre>"},{"location":"reference/cli/#tome-vault-delete","title":"<code>tome vault delete</code>","text":"<p>Deletes an existing vault and all secrets within it. This action is irreversible.</p> <p>Usage:</p> <pre><code>$ tome vault delete --help\n\nusage: tome vault delete [-h] [-v] [-q] [-f FORMAT] [-p PASSWORD] [-n NAME]\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --verbose         Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet           Reduce the output to a minimum, showing only critical errors\n  -f FORMAT, --format FORMAT\n                        Select the output format: json\n  -p PASSWORD, --password PASSWORD\n                        Tome vault password (Prompt if not specified)\n  -n NAME, --name NAME  Vault name (will use the \"default\" vault if not specified)\n</code></pre>"},{"location":"reference/cli/#tome-vault-add-secret","title":"<code>tome vault add-secret</code>","text":"<p>Adds a new secret (a key-value pair) to a specified vault.</p> <p>Usage:</p> <pre><code>$ tome vault add-secret --help\n\nusage: tome vault add-secret [-h] [-v] [-q] [-f FORMAT] [-p PASSWORD] [-u]\n                              [--description DESCRIPTION] [-vn VAULT]\n                              name text\n\npositional arguments:\n  name                  Secret text name\n  text                  Secret text content\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --verbose         Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet           Reduce the output to a minimum, showing only critical errors\n  -f FORMAT, --format FORMAT\n                        Select the output format: json\n  -p PASSWORD, --password PASSWORD\n                        Tome vault password (Prompt if not specified)\n  -u, --update          Update if exists\n  --description DESCRIPTION\n                        Secret text description\n  -vn VAULT, --vault VAULT\n                        Vault name (will use the \"default\" vault if not specified)\n</code></pre>"},{"location":"reference/cli/#tome-vault-delete-secret","title":"<code>tome vault delete-secret</code>","text":"<p>Removes a specific secret from a vault.</p> <p>Usage:</p> <pre><code>$ tome vault delete-secret --help\n\nusage: tome vault delete-secret [-h] [-v] [-q] [-f FORMAT] [-p PASSWORD]\n                                [-vn VAULT]\n                                name\n\npositional arguments:\n  name                  Secret text name\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --verbose         Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet           Reduce the output to a minimum, showing only critical errors\n  -f FORMAT, --format FORMAT\n                        Select the output format: json\n  -p PASSWORD, --password PASSWORD\n                        Tome vault password (Prompt if not specified)\n  -vn VAULT, --vault VAULT\n                        Vault name (will use the \"default\" vault if not specified)\n</code></pre>"},{"location":"reference/cli/#tome-vault-list-secrets","title":"<code>tome vault list-secrets</code>","text":"<p>Lists the names and descriptions of all secrets stored in all vaults. The secret values themselves are not displayed.</p> <p>Usage:</p> <pre><code>$ tome vault list-secrets --help\n\nusage: tome vault list-secrets [-h] [-v] [-q] [-f FORMAT]\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --verbose         Increase the level of verbosity (use -v, -vv, -vvv, etc.)\n  -q, --quiet           Reduce the output to a minimum, showing only critical errors\n  -f FORMAT, --format FORMAT\n                        Select the output format: json\n</code></pre>"},{"location":"reference/environment_variables/","title":"Environment Variables","text":"<p>tome's behavior can be influenced by environment variables. Setting these before running tome allows for customization.</p>"},{"location":"reference/environment_variables/#tome_home","title":"<code>TOME_HOME</code>","text":"<ul> <li> <p>Purpose: Specifies a custom absolute path for the tome home directory.     This is where tome stores its operational data, including cached     scripts, local storage, and vaults.</p> </li> <li> <p>Default Value: If not set, tome uses a <code>.tome</code> directory in your user     home (e.g., <code>~/.tome</code> on Linux/macOS).</p> </li> <li> <p>Example Usage (Linux/macOS):</p> </li> </ul> <pre><code>$ export TOME_HOME=\"/path/to/my/custom_tome_home\"\n$ tome list\n# tome will now use the custom path\n</code></pre> <p>You can check the active home directory with <code>tome config home</code>.</p> <pre><code>$ tome config home\n/path/to/my/custom_tome_home\n</code></pre>"},{"location":"reference/python_api/","title":"Python API Reference","text":"<p>This section provides detailed information for developers creating custom tome Commands using Python.</p>"},{"location":"reference/python_api/#tome_command-decorator","title":"<code>@tome_command()</code> Decorator","text":"<p>The <code>@tome_command()</code> decorator is the primary mechanism for registering a Python function as a runnable tome Command. It tells tome that your function should be discoverable and executable through the CLI.</p> <pre><code>from tome.command import tome_command\n\n@tome_command(parent=None, formatters=None)\ndef my_command_function(tome_api, parser, *args):\n    # Your command logic here\n    pass\n</code></pre> <p>Parameters:</p> <ul> <li> <p><code>parent</code> (optional, default: <code>None</code>): If this command is intended to be a   subcommand of another tome Command, set this parameter to the function   object of the parent command. This enables a hierarchical command structure   (e.g., <code>tome maincommand subcommand</code>). For a practical example, see the   \"Building Commands with   Subcommands\" section in our   In-Depth guide.</p> </li> <li> <p><code>formatters</code> (optional, default: <code>None</code>): A dictionary that maps output format   names (strings, e.g., <code>\"text\"</code>, <code>\"json\"</code>) to Python functions that will handle   the presentation of data returned by your command. When formatters are   defined, tome automatically adds a <code>--format</code> option to your command.   Learn more in the \"Standardizing Output using   Formatters\"   section of the In-Depth guide and in the Output   Formatters section below.</p> </li> </ul> <p>Python functions decorated with <code>@tome_command()</code> must follow a specific signature to correctly receive information and tools from tome:</p> <pre><code>def your_command_name(tome_api, parser, *args):\n    # Command implementation\n    # ...\n</code></pre> <p>Parameters Injected by <code>tome</code>:</p> <ul> <li> <p><code>tome_api</code> (<code>TomeAPI</code> instance): This object is your script's gateway to     tome's core functionalities. Key attributes include:</p> <ul> <li> <p><code>tome_api.vault</code>: Provides access to the tome Vault for secure secret   management. (See Vault API below).</p> </li> <li> <p><code>tome_api.store.folder</code> (string): The absolute path to a dedicated local   storage directory for the current Tome, where your script can   read/write persistent data. (See Store API   below).</p> </li> </ul> </li> <li> <p><code>parser</code> (<code>TomeArgumentParser</code> instance): An instance of an     <code>argparse.ArgumentParser</code> subclass. Use this object to define the     command-line arguments and options that your Command accepts, using     standard <code>argparse</code> methods like <code>parser.add_argument()</code>.</p> </li> <li> <p><code>*args</code> (tuple): A tuple containing the raw command-line arguments passed by     the user after the Command's name (and any subcommand names). These are     typically processed by calling <code>parsed_args = parser.parse_args(*args)</code>.</p> </li> </ul>"},{"location":"reference/python_api/#argument-parsing-using-parser","title":"Argument Parsing (using <code>parser</code>)","text":"<p>Within your command function, use the provided <code>parser</code> object as you would with Python's standard <code>argparse</code> library to define how your command accepts input:</p> <pre><code># Example within your command function:\nparser.add_argument('filename', help=\"The path to the file to process.\")\nparser.add_argument('--lines', type=int, default=10, help=\"Number of lines to display (default: 10).\")\nparser.add_argument('--verbose', '-v', action='store_true', help=\"Enable verbose output.\")\n\nparsed_args = parser.parse_args(*args)\n\n# You can then access the values:\n# file_to_process = parsed_args.filename\n# num_lines = parsed_args.lines\n# if parsed_args.verbose:\n#     print(\"Verbose mode enabled.\")\n</code></pre>"},{"location":"reference/python_api/#tomeoutput","title":"<code>TomeOutput</code>","text":"<p>For producing console output (informational messages, errors, warnings, or structured data like JSON), it is highly recommended to use the <code>TomeOutput</code> class from <code>tome.api.output</code>. This utility ensures that your command's output is consistent with tome's overall style and respects its verbosity settings (controlled by <code>-v</code> or <code>-q</code> flags).</p> <pre><code>from tome.api.output import TomeOutput\nimport json # For print_json example\n\n# General messages (typically go to stderr by default)\noutput = TomeOutput()\noutput.info(\"This is an informational message.\")\noutput.error(\"This is an error message.\")\noutput.warning(\"This is a warning.\")\n\n# For primary command output (e.g., results, data - typically to stdout)\ndata_output = TomeOutput(stdout=True)\ndata_for_json = {\"key\": \"value\", \"items\": [1, 2, 3]}\ndata_output.print(\"This is the main result of the command.\")\ndata_output.print_json(json.dumps(data_for_json, indent=2))\n</code></pre> <p>Note on <code>stdout</code> vs. <code>stderr</code>: By default, <code>TomeOutput()</code> directs its messages (like <code>.info()</code>, <code>.warning()</code>, <code>.error()</code>) to <code>stderr</code>. This is a common practice for diagnostic and informational messages in CLI tools, reserving <code>stdout</code> for the primary data output of a command (which might be piped to other tools). If your command's main result is textual, use <code>TomeOutput(stdout=True).print()</code> or <code>TomeOutput(stdout=True).info()</code> for that specific output. Formatter functions also typically use <code>TomeOutput(stdout=True)</code>.</p>"},{"location":"reference/python_api/#output-formatters","title":"Output Formatters","text":"<p>When a Command needs to present its results in multiple formats (e.g., human-readable text, JSON for scripts), tome's formatter system provides a clean solution. Instead of the command function printing directly, it <code>return</code>s data (usually a dictionary). Formatter functions, registered via the <code>formatters</code> argument in <code>@tome_command</code>, then handle the presentation. This way we have several advantages:</p> <ul> <li>Separation of Concerns: Command logic (processing data) is decoupled from   presentation logic (displaying data). This leads to cleaner, more maintainable   code.</li> <li>Flexible Output: Offer multiple output formats (text, JSON, YAML, etc.)   from a single command logic, catering to different users or automation needs.</li> <li>Consistency: Standardize how data and errors are presented across   different commands.</li> </ul> <p>Defining and Using Formatters:</p> <ol> <li>Command Function Returns Data: Your command function should return a     dictionary (or other serializable data).</li> </ol> <pre><code>@tome_command(formatters={\"text\": my_text_formatter, \"json\": my_json_formatter})\ndef my_data_command(tome_api, parser, *args):\n    # ... process and gather data ...\n    result_data = {\"item_name\": \"Example\", \"value\": 42, \"status\": \"success\"}\n    return result_data\n</code></pre> <ol> <li>Create Formatter Functions: Each formatter is a Python function that     accepts one argument (the data dictionary returned by your command) and uses     <code>TomeOutput</code> to print it.</li> </ol> <pre><code># In your script:\ndef my_text_formatter(data):\n    TomeOutput(stdout=True).info(f\"Item: {data.get('item_name')}, Value: {data.get('value')}\")\n\ndef my_json_formatter(data):\n    import json\n    TomeOutput(stdout=True).print_json(json.dumps(data, indent=2))\n</code></pre> <p>If the data dictionary contains an error (e.g., <code>{\"status\": \"error\", \"error\": \"Something went wrong\"}</code>), your formatter should typically raise a <code>TomeException(data[\"error\"])</code> so tome can handle the error reporting and exit code appropriately.</p> <p>Users can then select an output format: <code>$ tome yournamespace:my_data_command --format json</code></p> <p>If <code>--format</code> is not provided, tome will attempt to use a formatter named <code>\"text\"</code> by default.</p>"},{"location":"reference/python_api/#error-handling","title":"Error Handling","text":"<p>To signal operational errors from your Command or formatters, <code>raise TomeException</code> from <code>tome.errors</code>.</p> <pre><code>```python\nfrom tome.errors import TomeException\n# if error_condition:\n#     raise TomeException(\"Specific error description.\")\n```\n</code></pre> <p>tome will catch these exceptions, print a standardized error message to <code>stderr</code>, and exit with a non-zero status code (typically <code>1</code>).</p>"},{"location":"reference/python_api/#vault-api-for-scripts","title":"Vault API (for Scripts)","text":"<p>Access secrets via <code>tome_api.vault</code> (an instance of <code>VaultApi</code>).</p> <p><code>tome_api.vault</code> Methods:</p> <ul> <li><code>open(name='default', password=None) -&gt; Vault</code>: Opens a vault. Raises   <code>TomeException</code> on failure.</li> <li><code>create(name, password)</code>: Creates a new vault.</li> <li><code>list() -&gt; dict</code>: Lists vaults and their secret names/descriptions.</li> </ul> <p><code>Vault</code> Instance Methods:</p> <ul> <li><code>my_vault.read(name: str) -&gt; str | None</code>: Reads a secret's value.</li> <li><code>my_vault.create(name, text, description=None, update=False) -&gt; State</code>:   Adds/updates a secret.</li> <li><code>my_vault.delete(name: str)</code>: Deletes a secret.</li> <li><code>my_vault.list() -&gt; list</code>: Lists secrets (name, description) in the opened   vault.</li> </ul> <p>See the Vault Guide for full examples.</p>"},{"location":"reference/python_api/#store-api-for-scripts","title":"Store API (for Scripts)","text":"<p>Access a persistent local storage directory via <code>tome_api.store.folder</code> (string path, typically <code>~/.tome/storage/</code>). Use this for script-specific configurations, caches, or data files.</p> <p>See the Store Guide for practical examples.</p>"},{"location":"resources/glossary/","title":"Glossary","text":"<p>Throughout this documentation, you will encounter several terms related to tome. Here are definitions for some of the most important ones:</p> <ul> <li> <p>Command A runnable function defined within a Script file. In Python     Scripts, these are typically functions decorated with <code>@tome_command()</code>.     Commands belong to a Tome and are accessed via the tome tool     using their Namespace and name (e.g., <code>tome namespace:command_name</code>).</p> </li> <li> <p>Namespace The primary identifier used within the tome tool to group     and access a collection of Commands originating from a specific     Tome. It prevents naming conflicts, allowing, for example,     <code>utils:cleanup</code> and <code>backup:cleanup</code> to coexist as distinct Commands.</p> </li> <li> <p>Origin The source location from which the Scripts constituting a     Tome are fetched or installed. Common examples include a Git repository,     a local filesystem directory, or a ZIP archive.</p> </li> <li> <p>Script A file (e.g., a Python <code>.py</code> file, or a shell script such as     <code>.sh</code>, <code>.bat</code>) that contains the source code defining one or more     Commands. Scripts are part of a Tome.</p> </li> <li> <p>Tome A logical collection of Scripts that are sourced from a common     Origin.</p> </li> </ul>"},{"location":"resources/glossary/#concepts-in-action","title":"Concepts in Action","text":"<p>Now, let's see how these terms apply in a practical scenario. We'll use <code>tome new</code> to set up a small project.</p> <p>Imagine you start in an empty directory:</p> <ul> <li>Create a project folder and navigate into it:</li> </ul> <pre><code>$ mkdir my-tome\n$ cd my-tome\n</code></pre> <ul> <li>Generate two new commands using <code>tome new</code>, each in a different namespace</li> </ul> <pre><code>$ tome new greetings:hello\n$ tome new utils:showtime\n</code></pre> <ul> <li>This action creates a directory structure similar to this:</li> </ul> <pre><code>my-tome/\n\u251c\u2500\u2500 greetings/\n\u2502   \u2514\u2500\u2500 hello.py  (plus a tests/ directory)\n\u2514\u2500\u2500 utils/\n    \u2514\u2500\u2500 showtime.py (plus a tests/ directory)\n</code></pre> <ul> <li>Install this Tome as editable.</li> </ul> <pre><code>$ tome install . -e\n</code></pre> <p>Now, let's connect this setup to our glossary terms:</p> <ul> <li>The <code>my-tome/</code> directory serves as the Origin for your scripts, it's their   source location.</li> <li>This collection of all scripts and files within <code>my-tome/</code> that tome now   manages is a Tome.</li> <li>The subdirectories <code>greetings/</code> and <code>utils/</code> function as Namespaces,   organizing your commands.</li> <li>Files like <code>greetings/hello.py</code> and <code>utils/showtime.py</code> are the Scripts   where your command logic resides.</li> <li>The actual runnable tasks defined within these Scripts (e.g., the <code>hello</code>   function in <code>hello.py</code>, exposed via <code>@tome_command</code>) become the Commands   you can execute (like <code>tome greetings:hello</code>).</li> </ul>"}]}